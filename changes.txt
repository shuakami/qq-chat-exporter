diff --git a/components/ChatExporter.js b/components/ChatExporter.js
index b394f2b..6fca4af 100644
--- a/components/ChatExporter.js
+++ b/components/ChatExporter.js
@@ -347,31 +347,28 @@ export function createChatExporter(db, recordId, messageCount) {
   });
 
   previewBtn.addEventListener('click', async () => {
-    const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
     try {
-      await previewChatRecords(db, recordId, sortOrder);
+      await previewChatRecords(db, recordId, 'asc');
     } catch (error) {
-      logger.error('预览失败:', error);
+      logger.error(`预览失败: ${error.message}`);
       console.error('预览失败:', error);
     }
   });
 
   exportJsonBtn.addEventListener('click', async () => {
-    const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
     try {
-      await exportChatRecords(db, recordId, 'json', sortOrder);
+      await exportChatRecords(db, recordId, 'json', 'asc');
     } catch (error) {
-      logger.error('导出JSON失败:', error);
+      logger.error(`导出JSON失败: ${error.message}`);
       console.error('导出JSON失败:', error);
     }
   });
 
   exportTxtBtn.addEventListener('click', async () => {
-    const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
     try {
-      await exportChatRecords(db, recordId, 'txt', sortOrder);
+      await exportChatRecords(db, recordId, 'txt', 'asc');
     } catch (error) {
-      logger.error('导出TXT失败:', error);
+      logger.error(`导出TXT失败: ${error.message}`);
       console.error('导出TXT失败:', error);
     }
   });
diff --git a/components/HistoryManager.js b/components/HistoryManager.js
index 414bc8a..4ed57c7 100644
--- a/components/HistoryManager.js
+++ b/components/HistoryManager.js
@@ -156,7 +156,7 @@ export async function createHistoryManager() {
 
     .history-item-actions {
       display: grid;
-      grid-template-columns: repeat(3, 1fr);
+      grid-template-columns: repeat(4, 1fr);
       gap: 8px;
       margin-top: 12px;
     }
@@ -351,6 +351,14 @@ export async function createHistoryManager() {
               </svg>
               预览
             </button>
+            <button class="history-item-btn danger" data-action="delete" data-db="${dbInfo.name}">
+              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
+                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
+                <line x1="10" y1="11" x2="10" y2="17"/>
+                <line x1="14" y1="11" x2="14" y2="17"/>
+              </svg>
+              删除
+            </button>
           </div>
         `;
 
@@ -377,6 +385,30 @@ export async function createHistoryManager() {
               case 'preview':
                 await previewChatRecords(db, sessionId, 'asc');
                 break;
+              case 'delete':
+                if (confirm(`确定要删除这条历史记录吗？\n对话者：${senders.join(', ')}\n消息数：${records.length}\n时间：${timestamp.toLocaleString()}\n\n此操作不可恢复！`)) {
+                  try {
+                    await db.close();
+                    await Dexie.delete(dbName);
+                    historyItem.remove();
+                    logger.success('历史记录已删除');
+                    
+                    // 更新统计信息
+                    const remainingItems = historyList.querySelectorAll('.history-item').length;
+                    const remainingRecords = Array.from(historyList.querySelectorAll('.history-item-info'))
+                      .reduce((sum, info) => sum + parseInt(info.textContent.match(/\d+/)[0]), 0);
+                    stats.textContent = `共 ${remainingItems} 条历史记录，${remainingRecords} 条消息`;
+                    
+                    // 如果没有记录了，显示空状态
+                    if (remainingItems === 0) {
+                      emptyState.style.display = 'block';
+                      emptyState.textContent = '暂无历史记录';
+                    }
+                  } catch (error) {
+                    logger.error(`删除失败: ${error.message}`);
+                  }
+                }
+                break;
             }
           });
         });
diff --git a/main-exporter-pro.js b/main-exporter-pro.js
index d56f02e..42f73c6 100644
--- a/main-exporter-pro.js
+++ b/main-exporter-pro.js
@@ -2,7 +2,6 @@ import logger from './utils/logger.js';
 import { delay, scrollWithMethod } from './utils/scroll.js';
 import { createChatExporter } from './components/ChatExporter.js';
 import { showExportHelp, exportChatRecords, previewChatRecords } from './utils/export.js';
-import { createDatePicker, selectSpecificDate, processLatestChatMessage } from './utils/datePicker.js';
 
 // 版本信息
 const VERSION = '2.0.0';
@@ -27,8 +26,8 @@ window.QCEPro = {
       }
 
       // 初始化日志
-      console.log(`%c QQ Chat Exporter Pro v${VERSION} %c | https://github.com/shuakami/qq-chat-exporter `, 
-        'background:#1e90ff;color:#fff;padding:5px 10px;border-radius:4px 0 0 4px;', 
+      console.log(`%c QQ Chat Exporter Pro v${VERSION} %c | https://github.com/shuakami/qq-chat-exporter `,
+        'background:#1e90ff;color:#fff;padding:5px 10px;border-radius:4px 0 0 4px;',
         'background:#fff;color:#1e90ff;padding:5px 10px;border-radius:0 4px 4px 0;border:1px solid #1e90ff;');
 
       // 确保Selection API可用
@@ -40,37 +39,6 @@ window.QCEPro = {
       // 初始化基础配置
       logger.startSection('初始化配置');
 
-      // 0.0 日期选择 - 在开始导出前询问用户是否要选择特定日期
-      logger.info("加载日期选择器...");
-      const targetDate = await createDatePicker();
-      
-      // 如果用户选择了日期，则导航到该日期并处理消息
-      if (targetDate) {
-        logger.highlight(`用户选择了日期: ${targetDate.year}-${targetDate.month}-${targetDate.day}`);
-        
-        const dateSelected = await selectSpecificDate(targetDate);
-        if (!dateSelected) {
-          logger.error("日期选择失败，可能是该日期没有聊天记录。即将使用当前日期继续。");
-          await delay(2000); // 给用户时间阅读错误信息
-        } else {
-          logger.success("日期选择成功！");
-          
-          // 处理该日期的最新消息
-          const messageProcessed = await processLatestChatMessage();
-          if (!messageProcessed) {
-            logger.warning("处理消息失败，可能无法跳转到选定的聊天记录位置。即将继续导出当前可见消息。");
-            await delay(2000); // 给用户时间阅读警告信息
-          } else {
-            logger.success("已成功导航到选定的聊天记录位置！");
-            await delay(1000); // 给页面一点时间加载
-          }
-        }
-      } else if (targetDate === false) {
-        logger.system("用户选择跳过日期选择，将从当前日期开始导出。");
-      } else {
-        logger.warning("用户取消了操作，但我们仍将继续导出当前可见的聊天记录。");
-      }
-
       // 0.0.1 滚动方向选择
       logger.info("选择滚动方向...");
       const scrollDirection = await new Promise(resolve => {
@@ -114,7 +82,7 @@ window.QCEPro = {
           margin-bottom: 16px;
         `;
 
-        const createButton = (text, value, description) => {
+        const createButton = (text, value, desc) => {
           const button = document.createElement('button');
           button.style.cssText = `
             flex: 1;
@@ -131,14 +99,14 @@ window.QCEPro = {
             color: #666;
             min-height: 120px;
           `;
-          
+
           const iconSpan = document.createElement('span');
           iconSpan.textContent = value === 'up' ? '⬆️' : '⬇️';
           iconSpan.style.cssText = `
             font-size: 28px;
             margin-bottom: 4px;
           `;
-          
+
           const textSpan = document.createElement('span');
           textSpan.textContent = text;
           textSpan.style.cssText = `
@@ -146,16 +114,16 @@ window.QCEPro = {
             font-weight: 500;
             margin-bottom: 8px;
           `;
-          
+
           const descSpan = document.createElement('span');
-          descSpan.textContent = description;
+          descSpan.textContent = desc;
           descSpan.style.cssText = `
             font-size: 13px;
             color: #888;
             text-align: center;
             line-height: 1.4;
           `;
-          
+
           button.appendChild(iconSpan);
           button.appendChild(textSpan);
           button.appendChild(descSpan);
@@ -247,31 +215,32 @@ window.QCEPro = {
       }
 
       // 全局数据
-      window.collectedMessages = [];    // 保存所有提取到的消息
+      // 优化：不在内存中长期存放所有消息，仅临时存储一批后写入
+      window.collectedMessages = [];
       window.processedIds = new Set();  // 用于去重
 
       // ========== 0.1 主要滚动参数 ==========
-      const upTimes = scrollDirection === 'up' ? 5 : 1;     // 上滑次数
-      const downTimes = scrollDirection === 'up' ? 1 : 10;    // 下滑次数
-      
+      const upTimes = (scrollDirection === 'up') ? 5 : 2;    // 上滑次数
+      const downTimes = (scrollDirection === 'up') ? 2 : 10; // 下滑次数
+
       // 根据滚动方向设置不同的延迟时间
       const getDelayTime = (direction) => {
         if (direction === 'down') {
           return {
             scrollDelay: 300,      // 向下滚动等待时间
             focusInterval: 100,    // 向下滚动时焦点间隔
-            scrollDuration: 1800    // 向下滚动时持续时间
+            scrollDuration: 1800   // 向下滚动时持续时间
           };
         } else {
           return {
-            scrollDelay: 900,      // 向上滚动等待时间
-            focusInterval: 300,    // 向上滚动时焦点间隔
-            scrollDuration: 2400   // 向上滚动时持续时间
+            scrollDelay: 450,      // 向上滚动等待时间
+            focusInterval: 150,    // 向上滚动时焦点间隔
+            scrollDuration: 1200   // 向上滚动时持续时间
           };
         }
       };
 
-      const maxNoNewTimes = 20;         // 连续n次无新消息则停止
+      const maxNoNewTimes = 50;         // 连续n次无新消息则停止
       const scrollThreshold = 50;       // 滚动检测阈值
 
       // ========== 0.2 其他控制变量 ==========
@@ -286,7 +255,13 @@ window.QCEPro = {
         isManualStop = true;
         logger.highlight('已手动停止自动滚动');
       };
-      
+
+      // 添加提前结束函数
+      window.finishNow = function() {
+        noNewTimes = maxNoNewTimes;
+        logger.highlight('已触发提前结束，正在完成最后的数据保存...');
+      };
+
       // 暴露导出和预览功能到全局作用域
       window.exportChatRecords = async (format, sortOrder) => {
         try {
@@ -303,7 +278,7 @@ window.QCEPro = {
           throw error;
         }
       };
-        
+
       window.previewChatRecords = async (sortOrder) => {
         try {
           if (!db) {
@@ -319,19 +294,12 @@ window.QCEPro = {
           throw error;
         }
       };
-      
+
       // 同时保持QCEPro对象的方法
       window.QCEPro.exportChatRecords = window.exportChatRecords;
       window.QCEPro.previewChatRecords = window.previewChatRecords;
-        
+
       window.howToExport = showExportHelp;
-      
-      // 暴露日期选择工具类
-      window.datePickerUtils = {
-        selectSpecificDate,
-        processLatestChatMessage,
-        delay
-      };
 
       // 注册全局快捷键：Ctrl+F8 切换暂停/恢复
       window.addEventListener("keydown", function(e) {
@@ -340,6 +308,7 @@ window.QCEPro = {
           isPaused = !isPaused;
           if (isPaused) {
             logger.warning(`已暂停自动滚动 (Ctrl+F8 可恢复)`);
+            logger.warning('如果想提前结束采集，按Ctrl+F8继续，然后在控制台输入：window.finishNow() 并回车');
           } else {
             logger.success(`已恢复自动滚动`);
           }
@@ -354,6 +323,9 @@ window.QCEPro = {
 
       // ========== 1. 主循环: 5次上滑 + 1次下滑的反复 ==========
       logger.startSection('开始滚动采集');
+      let consecutiveInvalidScrolls = 0;  // 添加连续无效滚动计数器
+      let hasTriedRecovery = false;      // 添加恢复机制执行标记
+      
       mainLoop: while (!isManualStop) {
         // 检查是否处于暂停状态
         while (isPaused && !isManualStop) {
@@ -376,11 +348,18 @@ window.QCEPro = {
       }
 
       logger.endSection('滚动采集');
-      logger.success(`共收集消息数: ${window.collectedMessages.length}条`);
+      logger.success(`【本次采集结束】已收集消息数: ${window.processedIds.size} 条`);
       
+      // 如果是异常终止（连续无新消息或手动停止），提示继续任务
+      if (noNewTimes >= maxNoNewTimes || isManualStop) {
+        logger.system('如果说采集意外中断了？');
+        logger.system('别担心！如果想继续采集剩余的消息：');
+        logger.system('在控制台输入：window.QCEPro.continueTask() 并回车');
+      }
+
       // 创建导出工具UI
       try {
-        const chatExporter = await createChatExporter(db, recordId, window.collectedMessages.length);
+        const chatExporter = await createChatExporter(db, recordId, window.processedIds.size);
         if (!chatExporter) {
           throw new Error("导出工具UI创建失败");
         }
@@ -388,97 +367,111 @@ window.QCEPro = {
         logger.error(`创建导出工具失败: ${error.message}`);
         throw error;
       }
-      
+
       // 显示导出帮助信息
       showExportHelp();
-      
+
       // 显示可爱的点赞请求
       showStarRequest();
-      
+
       logger.highlight('如果你要重新执行脚本/切换好友继续进行备份，请一定要先点击F5刷新后继续。');
 
-      // ========== 2. 定义"单步滚动+提取"函数 ==========
-      // 返回 true 表示应终止整个上滑逻辑
+      // ========== 2. 优化后的 "单步滚动+提取"函数 ==========
+      // 返回 true 表示应终止整个滚动逻辑
       async function doScrollOneStep(direction) {
         cycleCount++;
-        const oldScrollTop = container.scrollTop;
-        
-        // 获取当前方向的延迟时间
-        const delayTimes = getDelayTime(direction);
-        
         logger.event(`[滚动] 第${cycleCount}次, 方向=${direction}, 方法=${activeMethod}`);
-        
-        // 2.1 确保容器获得焦点
+
+        // 2.1 聚焦容器，并等待片刻以确保DOM渲染稳定
+        const { focusInterval, scrollDuration, scrollDelay } = getDelayTime(direction);
         container.focus();
-        await delay(delayTimes.focusInterval);
-        
-        // 2.2 使用当前活动方法滚动
-        await scrollWithMethod(container, direction, activeMethod, delayTimes.scrollDuration);
-        
-        // 检查滚动是否生效
-        await delay(delayTimes.scrollDelay);
+        await delay(focusInterval);
+
+        // 2.2 初次滚动
+        const oldScrollTop = container.scrollTop;
+        await scrollWithMethod(container, direction, activeMethod, scrollDuration);
+        await delay(scrollDelay);
+
+        // 2.3 判断滚动有效性，若不足阈值则切换方法再滚一次
         const newScrollTop = container.scrollTop;
         const scrollDiff = Math.abs(newScrollTop - oldScrollTop);
         
         if (scrollDiff < scrollThreshold) {
-          // 切换到下一种方法
+          consecutiveInvalidScrolls++;
           activeMethod = (activeMethod + 1) % 5;
           logger.warning(`滚动无效 (差异: ${scrollDiff}px)，切换到方法 ${activeMethod}`);
-          await scrollWithMethod(container, direction, activeMethod, delayTimes.scrollDuration);
-          await delay(delayTimes.scrollDelay);
         } else {
           logger.system(`滚动成功，位移: ${scrollDiff}px，方向: ${direction}`);
+          consecutiveInvalidScrolls = 0;  // 重置连续无效计数器
         }
 
-        // 2.3 提取本次新增消息，并存入 IndexedDB
-        const newCount = extractNewMessagesAndLog();
+        // 2.4 提取本次新增消息
+        const newCount = await extractNewMessagesAndLog();
         if (newCount > 0) {
-          // 将新增消息添加至 IndexedDB（附加 session 和 timestamp 字段）
-          const newMsgs = window.collectedMessages.slice(-newCount);
-          newMsgs.forEach(msg => {
-            msg.session = recordId;
-            msg.timestamp = new Date().toISOString();
-          });
-          try {
-            await db.records.bulkAdd(newMsgs);
-            logger.success(`已存储 ${newCount} 条新增消息到数据库`);
-          } catch (error) {
-            logger.error(`存储消息到数据库失败: ${error.message}`);
-          }
           noNewTimes = 0;
+          consecutiveInvalidScrolls = 0;  // 有新消息时也重置连续无效计数器
+          hasTriedRecovery = false;       // 有新消息时重置恢复机制标记
         } else {
           noNewTimes++;
-          logger.system(`无新消息，已连续 ${noNewTimes}/${maxNoNewTimes} 次`);
+          logger.system(`无新消息，已连续 ${noNewTimes}/${maxNoNewTimes} 次 （出现此提示请不要担心，到达限制时系统会自动停止）`);
+          
+          // 在连续25次无新消息且未执行过恢复机制时，尝试恢复
+          if (noNewTimes >= 25 && !hasTriedRecovery) {
+            logger.warning('检测到连续25次无新消息，启动恢复机制...');
+            logger.system('暂停5秒，然后尝试反向滚动来恢复...');
+            
+            // 暂停5秒
+            await delay(5000);
+            
+            // 执行2次反向滚动
+            const oppositeDirection = direction === 'up' ? 'down' : 'up';
+            logger.system(`执行反向滚动 (${oppositeDirection})...`);
+            
+            for (let i = 0; i < 2; i++) {
+              await scrollWithMethod(container, oppositeDirection, activeMethod, scrollDuration * 1.5);
+              await delay(scrollDelay * 1.5);
+            }
+            
+            // 标记已执行过恢复机制
+            hasTriedRecovery = true;
+            logger.system('恢复机制执行完毕，继续正常滚动...');
+            logger.system('如果后续仍然无效，将等待达到最大无消息次数后自动停止。');
+          }
+          
           if (noNewTimes >= maxNoNewTimes) {
             logger.warning(`已达到最大无消息次数 (${maxNoNewTimes})，停止滚动`);
-            return true;
+            return true; // 结束整个滚动流程
           }
         }
-
-        return false;
+        return false; // 继续
       }
 
-      // ========== 3. 提取当前DOM中出现的"新消息"并打印 ==========
-      function extractNewMessagesAndLog() {
+      // ========== 3. 从DOM中提取新的消息并写入DB ==========
+      async function extractNewMessagesAndLog() {
         let newCount = 0;
         const items = document.querySelectorAll(messageItemSelector);
-        for (const item of items) {
+        const batchToSave = [];
+
+        for (let i = 0; i < items.length; i++) {
+          const item = items[i];
           const id = item.getAttribute('id') || '';
           if (!id || window.processedIds.has(id)) {
             continue;
           }
+
           const timeEl = item.querySelector('.message__timestamp .babble');
           const time = timeEl ? timeEl.innerText.trim() : '';
+
           const avatarSpan = item.querySelector('.avatar-span');
-          const sender = avatarSpan ? avatarSpan.getAttribute('aria-label') || '' : '';
+          const sender = avatarSpan ? (avatarSpan.getAttribute('aria-label') || '') : '';
+
           let content = '';
-          
-          // 文本消息处理
+          // 文本消息
           const textEl = item.querySelector('.text-element');
           if (textEl && textEl.innerText.trim() !== '') {
             content = textEl.innerText.trim();
-          } 
-          // 图片消息处理
+          }
+          // 图片或视频
           else {
             const imgEl = item.querySelector('img.image-content');
             if (imgEl) {
@@ -487,60 +480,73 @@ window.QCEPro = {
               if (src.startsWith('data:')) {
                 src = src.slice(0, 50) + '...';
               }
-              
-              // 判断是否为视频消息
+
+              // 检查视频
               const videoElement = item.querySelector('.msg-preview--video');
               if (videoElement) {
-                // 视频消息处理
-                // 尝试获取视频文件路径
                 const finalSrc = videoElement.getAttribute('finalsrc') || '';
                 const videoLabel = videoElement.getAttribute('aria-label') || '视频';
-                
                 if (finalSrc) {
                   content = `[${videoLabel}] 路径: ${finalSrc}`;
                 } else {
                   content = `[${videoLabel}] 预览: ${dataPath || src}`;
                 }
               } else {
-                // 普通图片消息
                 content = `[图片] ${dataPath ? '路径: ' + dataPath : '预览: ' + src}`;
               }
             }
-            
-            // 如果没有找到图片元素，单独检查是否为视频消息
+
+            // 如果没有找到图片元素，单独检查是否为视频
             if (!content) {
               const videoElement = item.querySelector('.msg-preview--video');
               if (videoElement) {
                 const finalSrc = videoElement.getAttribute('finalsrc') || '';
                 const imgInVideo = videoElement.querySelector('img.image-content');
                 let videoPath = '';
-                
                 if (imgInVideo) {
-                  videoPath = imgInVideo.getAttribute('data-path') || imgInVideo.getAttribute('src') || '';
+                  videoPath = imgInVideo.getAttribute('data-path') ||
+                              imgInVideo.getAttribute('src') || '';
                 }
-                
-                content = `[视频] ${finalSrc ? '路径: ' + finalSrc : (videoPath ? '预览: ' + videoPath : '未知视频文件')}`;
+                content = `[视频] ${
+                  finalSrc ? '路径: ' + finalSrc :
+                  (videoPath ? '预览: ' + videoPath : '未知视频文件')
+                }`;
               }
             }
           }
-          
-          // 如果还是没有内容，尝试查找其他可能的消息类型
+
+          // 如果还是没有内容，尝试其他类型
           if (!content) {
-            if (item.textContent.trim()) {
-              content = `[未识别消息] ${item.textContent.trim().substring(0, 100)}${item.textContent.trim().length > 100 ? '...' : ''}`;
+            const pureText = (item.textContent || '').trim();
+            if (pureText) {
+              content = `[未识别消息] ${pureText.substring(0, 100)}${pureText.length > 100 ? '...' : ''}`;
             } else {
               content = '[未识别消息类型]';
             }
           }
-          
-          const messageData = { id, time, sender, content };
-          window.collectedMessages.push(messageData);
+
+          const messageData = {
+            id,
+            time,
+            sender,
+            content,
+            session: recordId,
+            timestamp: new Date().toISOString()
+          };
+
+          batchToSave.push(messageData);
           window.processedIds.add(id);
           newCount++;
-          
-          // 简洁日志
-          if (newCount % 5 === 0 || newCount === 1) {
-            logger.count(`已获取 ${window.collectedMessages.length} 条消息`);
+        }
+
+        // 将新消息批量写入IndexedDB
+        if (batchToSave.length > 0) {
+          try {
+            await db.records.bulkAdd(batchToSave);
+            window.collectedMessages = batchToSave; // 仅保留本次新增批次，减少内存占用
+            logger.success(`新增消息 ${newCount} 条 (累计总量: ${window.processedIds.size})`);
+          } catch (error) {
+            logger.error(`存储消息到数据库失败: ${error.message}`);
           }
         }
         return newCount;
@@ -549,6 +555,109 @@ window.QCEPro = {
       console.error('初始化失败:', error);
     }
   },
+  
+  // 添加继续任务方法
+  continueTask: async function() {
+    try {
+      logger.startSection('继续未完成任务');
+      
+      // 1. 确保 Dexie.js 已加载
+      if (!window.Dexie) {
+        logger.info("正在从国内CDN加载 Dexie.js...");
+        await new Promise((resolve, reject) => {
+          const script = document.createElement("script");
+          script.src = "https://cdn.bootcdn.net/ajax/libs/dexie/3.2.2/dexie.min.js";
+          script.onload = resolve;
+          script.onerror = (error) => {
+            logger.error("Dexie.js 加载失败，尝试使用备用CDN...");
+            script.src = "https://cdn.jsdelivr.net/npm/dexie@3.2.2/dist/dexie.min.js";
+            script.onload = resolve;
+            script.onerror = reject;
+          };
+          document.head.appendChild(script);
+        }).catch(error => {
+          logger.error("所有CDN加载失败，请检查网络连接");
+          throw new Error("依赖加载失败: " + error);
+        });
+        logger.success("Dexie.js 已成功加载");
+      }
+
+      // 2. 获取所有数据库列表
+      const dbList = await Dexie.getDatabaseNames();
+      const chatDbs = dbList.filter(name => name.startsWith('ChatRecords_'))
+        .sort((a, b) => {
+          const timeA = parseInt(a.split('_')[1].split('-')[0]);
+          const timeB = parseInt(b.split('_')[1].split('-')[0]);
+          return timeB - timeA;  // 降序排列
+        });
+      
+      if (chatDbs.length === 0) {
+        logger.error('未找到任何历史记录数据库');
+        return;
+      }
+
+      // 3. 显示所有数据库的详细信息
+      logger.highlight('找到以下历史记录数据库：');
+      for (const dbName of chatDbs) {
+        const db = new Dexie(dbName);
+        db.version(1).stores({
+          records: '++id, session, timestamp, time, sender, content'
+        });
+
+        // 获取该数据库的所有记录
+        const records = await db.records.toArray();
+        if (records.length === 0) continue;
+
+        // 获取对话者信息
+        const senders = [...new Set(records.map(r => r.sender))].filter(Boolean);
+        const participants = senders.join(' 与 ') || '未知对话者';
+
+        // 获取时间范围
+        const times = records.map(r => r.time).filter(Boolean);
+        const firstTime = times[0];
+        const lastTime = times[times.length - 1];
+
+        // 获取消息类型统计
+        const textMsgs = records.filter(r => !r.content.startsWith('[') && !r.content.includes('未识别')).length;
+        const imgMsgs = records.filter(r => r.content.includes('[图片]')).length;
+        const videoMsgs = records.filter(r => r.content.includes('[视频]')).length;
+        const otherMsgs = records.length - textMsgs - imgMsgs - videoMsgs;
+
+        // 显示数据库详细信息
+        logger.system(`\n== 数据库：${dbName} ==`);
+        logger.system(`对话者：${participants}`);
+        logger.system(`总消息数：${records.length} 条`);
+        logger.system(`时间范围：${firstTime} 至 ${lastTime}`);
+        logger.system('消息类型统计：');
+        logger.system(`- 文本消息：${textMsgs} 条`);
+        logger.system(`- 图片消息：${imgMsgs} 条`);
+        logger.system(`- 视频消息：${videoMsgs} 条`);
+        logger.system(`- 其他类型：${otherMsgs} 条`);
+      }
+
+      // 4. 获取最新数据库的最后记录
+      const latestDb = new Dexie(chatDbs[0]);
+      latestDb.version(1).stores({
+        records: '++id, session, timestamp, time, sender, content'
+      });
+      const lastRecord = await latestDb.records.orderBy('id').last();
+      
+      // 5. 显示继续采集的操作指引
+      logger.highlight('\n=== 如何继续采集 ===');
+      logger.system('1. 请先刷新页面（按F5）');
+      logger.system('2. 重新运行脚本');
+      logger.system('3. 点击QQ聊天窗口右上角的"消息记录"按钮');
+      logger.system(`4. 找到这个时间点附近的消息：${lastRecord.time}`);
+      logger.system('5. 点击该消息，页面会自动滚动到对应位置');
+      logger.system('6. 重新运行脚本，开始采集');
+      logger.system('\n提示：每次继续采集前，都需要先刷新页面(F5)，这样可以确保数据采集的准确性。');
+      
+    } catch (error) {
+      logger.error(`继续任务失败: ${error.message}`);
+      console.error('继续任务失败:', error);
+    }
+  },
+  
   showExportHelp,
   exportChatRecords,
   previewChatRecords
@@ -588,4 +697,4 @@ function showStarRequest() {
     `%c熬夜开发不易，感谢你的支持和反馈！(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧`,
     styles.text
   );
-}
\ No newline at end of file
+}
diff --git a/public/dist/qce-history.bundle.js b/public/dist/qce-history.bundle.js
index 7bf0a78..1da9f03 100644
--- a/public/dist/qce-history.bundle.js
+++ b/public/dist/qce-history.bundle.js
@@ -321,7 +321,7 @@
 
     .history-item-actions {
       display: grid;
-      grid-template-columns: repeat(3, 1fr);
+      grid-template-columns: repeat(4, 1fr);
       gap: 8px;
       margin-top: 12px;
     }
@@ -516,6 +516,14 @@
               </svg>
               预览
             </button>
+            <button class="history-item-btn danger" data-action="delete" data-db="${dbInfo.name}">
+              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
+                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
+                <line x1="10" y1="11" x2="10" y2="17"/>
+                <line x1="14" y1="11" x2="14" y2="17"/>
+              </svg>
+              删除
+            </button>
           </div>
         `;
 
@@ -542,6 +550,30 @@
                 case 'preview':
                   await previewChatRecords(db, sessionId, 'asc');
                   break;
+                case 'delete':
+                  if (confirm(`确定要删除这条历史记录吗？\n对话者：${senders.join(', ')}\n消息数：${records.length}\n时间：${timestamp.toLocaleString()}\n\n此操作不可恢复！`)) {
+                    try {
+                      await db.close();
+                      await Dexie.delete(dbName);
+                      historyItem.remove();
+                      logger.success('历史记录已删除');
+                      
+                      // 更新统计信息
+                      const remainingItems = historyList.querySelectorAll('.history-item').length;
+                      const remainingRecords = Array.from(historyList.querySelectorAll('.history-item-info'))
+                        .reduce((sum, info) => sum + parseInt(info.textContent.match(/\d+/)[0]), 0);
+                      stats.textContent = `共 ${remainingItems} 条历史记录，${remainingRecords} 条消息`;
+                      
+                      // 如果没有记录了，显示空状态
+                      if (remainingItems === 0) {
+                        emptyState.style.display = 'block';
+                        emptyState.textContent = '暂无历史记录';
+                      }
+                    } catch (error) {
+                      logger.error(`删除失败: ${error.message}`);
+                    }
+                  }
+                  break;
               }
             });
           });
@@ -607,12 +639,27 @@
     if (!historyManager) {
       historyManager = await createHistoryManager();
     }
-    historyManager.show();
   }
 
+  // 注册快捷键
+  document.addEventListener('keydown', async (event) => {
+    if (event.ctrlKey && event.key === 'F9') {
+      event.preventDefault();
+      if (!historyManager) {
+        await init();
+      }
+      historyManager.show();
+    }
+  });
+
   // 导出全局方法
   window.QCEHistory = {
-    show: init
+    show: async () => {
+      if (!historyManager) {
+        await init();
+      }
+      historyManager.show();
+    }
   };
 
   // 等待 DOM 加载完成后初始化
diff --git a/public/dist/qce-pro.bundle.js b/public/dist/qce-pro.bundle.js
index 1375361..7043419 100644
--- a/public/dist/qce-pro.bundle.js
+++ b/public/dist/qce-pro.bundle.js
@@ -39,7 +39,7 @@
   };
 
   // 延迟函数
-  const delay$1 = (ms) => new Promise(resolve => setTimeout(resolve, ms));
+  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
 
   // 直接激活焦点并发送键盘事件
   function activateFocusAndPressKey(container, key) {
@@ -683,31 +683,28 @@
     });
 
     previewBtn.addEventListener('click', async () => {
-      const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
       try {
-        await previewChatRecords(db, recordId, sortOrder);
+        await previewChatRecords(db, recordId, 'asc');
       } catch (error) {
-        logger.error('预览失败:', error);
+        logger.error(`预览失败: ${error.message}`);
         console.error('预览失败:', error);
       }
     });
 
     exportJsonBtn.addEventListener('click', async () => {
-      const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
       try {
-        await exportChatRecords(db, recordId, 'json', sortOrder);
+        await exportChatRecords(db, recordId, 'json', 'asc');
       } catch (error) {
-        logger.error('导出JSON失败:', error);
+        logger.error(`导出JSON失败: ${error.message}`);
         console.error('导出JSON失败:', error);
       }
     });
 
     exportTxtBtn.addEventListener('click', async () => {
-      const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
       try {
-        await exportChatRecords(db, recordId, 'txt', sortOrder);
+        await exportChatRecords(db, recordId, 'txt', 'asc');
       } catch (error) {
-        logger.error('导出TXT失败:', error);
+        logger.error(`导出TXT失败: ${error.message}`);
         console.error('导出TXT失败:', error);
       }
     });
@@ -744,464 +741,6 @@
     };
   }
 
-  // 日期选择和消息处理工具
-
-  // -------------------- 工具函数 --------------------
-
-  function simulateClick(element) {
-    if (element) {
-      element.click();
-      console.log(`点击元素: ${element.textContent ? element.textContent.trim() : (element.className ? element.className : '按钮')}`);
-    } else {
-      console.error(`未找到可点击的元素`);
-    }
-  }
-
-  function forceVisibleAndClick(element) {
-    if (element) {
-      // 强制显示（如果需要）
-      element.style.display = 'block';
-      element.style.visibility = 'visible';
-      element.style.opacity = '1';
-      element.click();
-      console.log(`强制显示并点击元素: ${element.className}`);
-    } else {
-      console.error(`未找到需要强制显示和点击的元素`);
-    }
-  }
-
-  function delay(ms) {
-    return new Promise(resolve => setTimeout(resolve, ms));
-  }
-
-  // -------------------- 日期选择工具函数 --------------------
-
-  async function selectSpecificDate(targetDate) {
-    console.log('开始选择日期...');
-
-    const currentDate = new Date();
-    const currentYear = currentDate.getFullYear();
-    const currentMonth = currentDate.getMonth(); // 0-indexed
-    const currentDay = currentDate.getDate();
-
-    const targetYear = targetDate.year;
-    const targetMonth = targetDate.month - 1; // 转为0-indexed
-    const targetDay = targetDate.day;
-
-    if (targetYear > currentYear ||
-        (targetYear === currentYear && targetMonth > currentMonth) ||
-        (targetYear === currentYear && targetMonth === currentMonth && targetDay > currentDay)) {
-      console.error(`目标日期 ${targetYear}-${targetMonth + 1}-${targetDay} 超过当前时间，无法选择。`);
-      return false; // 返回 false 表示选择失败
-    }
-
-    // 步骤 0: 点击筛选按钮
-    const filterButtonCssPath = 'div.record-filter-btn[data-v-35f48dfb]';
-    const filterButton = document.querySelector(filterButtonCssPath);
-    if (filterButton) {
-      simulateClick(filterButton);
-      await delay(500); // 等待筛选选项展开
-    } else {
-      console.error('无法找到筛选按钮。');
-      return false; // 返回 false 表示选择失败
-    }
-
-    // 步骤 1: 点击打开日期选择器
-    const openDatePickerCssPath = 'div#ml-root > div:nth-of-type(3) > div > div:nth-of-type(2) > div:nth-of-type(2) > div';
-    simulateClick(document.querySelector(openDatePickerCssPath));
-    await delay(500); // 等待日期选择器展开
-
-    // 步骤 2: 导航到目标月份
-    let resetAttempted = false;
-
-    while (true) {
-      let currentDisplayedMonthYearElement = document.querySelector('div.vc-title span');
-
-      if (!currentDisplayedMonthYearElement) {
-        if (!resetAttempted) {
-          console.log('无法找到当前显示的月份和年份，尝试点击重置按钮...');
-          const resetButton = document.querySelector('span.reset-btn[data-v-846dfd24]');
-          if (resetButton) {
-            simulateClick(resetButton);
-            await delay(1000); // 等待重置完成
-            currentDisplayedMonthYearElement = document.querySelector('div.vc-title span'); // 再次尝试查找
-            resetAttempted = true;
-            if (currentDisplayedMonthYearElement) {
-              console.log('重置成功，重新找到月份和年份。');
-            } else {
-              console.error('重置后仍然无法找到当前显示的月份和年份。');
-              return false; // 返回 false 表示选择失败
-            }
-          } else {
-            console.error('无法找到重置按钮。');
-            return false; // 返回 false 表示选择失败
-          }
-        } else {
-          console.error('多次尝试后仍然无法找到当前显示的月份和年份。');
-          return false; // 返回 false 表示选择失败
-        }
-      }
-
-      const currentDisplayedMonthYearText = currentDisplayedMonthYearElement.textContent.trim();
-      const [currentDisplayedYearStr, currentDisplayedMonthStr] = currentDisplayedMonthYearText.split('-').map(s => s.trim());
-      const currentDisplayedYear = parseInt(currentDisplayedYearStr, 10);
-      const currentDisplayedMonth = parseInt(currentDisplayedMonthStr, 10) - 1; // Convert to 0-indexed
-
-      if (currentDisplayedYear === targetYear && currentDisplayedMonth === targetMonth) {
-        console.log(`已导航到目标月份: ${currentDisplayedYear}-${currentDisplayedMonth + 1}`);
-        break;
-      } else if (currentDisplayedYear > targetYear || (currentDisplayedYear === targetYear && currentDisplayedMonth > targetMonth)) {
-        // 点击左箭头
-        const prevMonthArrow = document.querySelector('div.vc-arrows-container > div.vc-arrow.is-left');
-        simulateClick(prevMonthArrow);
-        await delay(300);
-      } else {
-        // 点击右箭头
-        const nextMonthArrow = document.querySelector('div.vc-arrows-container > div.vc-arrow.is-right');
-        simulateClick(nextMonthArrow);
-        await delay(300);
-      }
-    }
-
-    // 步骤 3: 选择目标日期并判断是否禁用
-    const dayElements = document.querySelectorAll('div.vc-weeks div.vc-day');
-    let targetDayFound = false;
-
-    for (const dayElement of dayElements) {
-      const dayTextElement = dayElement.querySelector('span.vc-day-content');
-      if (dayTextElement) {
-        const dayText = dayTextElement.textContent.trim();
-        if (parseInt(dayText, 10) === targetDay) {
-          targetDayFound = true;
-          if (dayTextElement.classList.contains('is-disabled')) {
-            console.log(`目标日期 ${targetYear}-${targetMonth + 1}-${targetDay} 没有数据。`);
-            return false; // 返回 false 表示选择失败
-          } else if (!dayElement.classList.contains('is-not-in-month')) {
-            simulateClick(dayTextElement);
-            console.log(`选择日期: ${targetYear}-${targetMonth + 1}-${targetDay}`);
-            return true; // 返回 true 表示选择成功
-          }
-        }
-      }
-    }
-
-    if (!targetDayFound) {
-      console.error(`未找到目标日期: ${targetYear}-${targetMonth + 1}-${targetDay}`);
-    }
-    return false; // 返回 false 表示选择失败
-  }
-
-  // -------------------- 最新消息处理工具函数 --------------------
-
-  async function processLatestChatMessage() {
-    console.log('开始处理最新消息...');
-
-    // 步骤 1: 关闭筛选条件（如果打开）
-    const filterPanel = document.querySelector('div.message-filter[data-v-846dfd24]');
-    if (filterPanel) {
-      console.log('检测到筛选条件已打开，尝试关闭...');
-      const filterButton = document.querySelector('div.record-filter-btn[data-v-35f48dfb]');
-      if (filterButton) {
-        simulateClick(filterButton);
-        await delay(500); // 等待筛选条件关闭
-      } else {
-        console.warn('无法找到筛选按钮，可能无法关闭筛选条件。');
-      }
-    } else {
-      console.log('筛选条件未打开。');
-    }
-
-    // 步骤 2: 找到最新的消息
-    const msgLists = document.querySelectorAll('div.msg-list[data-v-33692f9a]');
-    if (msgLists.length > 0) {
-      const latestMsgList = msgLists[msgLists.length - 1]; // 获取最后一个 msg-list
-      const latestMsgDetail = latestMsgList.querySelector('div.record-msg-detail[data-v-33692f9a]');
-
-      if (latestMsgDetail) {
-        console.log('找到最新的消息。');
-
-        // 步骤 3: 强制可见并触发目标图标
-        const targetIcon = latestMsgDetail.querySelector('i.q-svg-icon.target-to-chat[data-v-357b03a8][data-v-33692f9a]');
-        if (targetIcon) {
-          forceVisibleAndClick(targetIcon);
-          return true; // 返回 true 表示处理成功
-        } else {
-          console.warn('在最新的消息中未找到目标图标。');
-          return false; // 返回 false 表示处理失败
-        }
-      } else {
-        console.warn('未找到最新的消息详情。');
-        return false; // 返回 false 表示处理失败
-      }
-    } else {
-      console.warn('未找到任何消息列表。');
-      return false; // 返回 false 表示处理失败
-    }
-  }
-
-  // 创建日期选择器UI
-  function createDatePicker(onSelect) {
-    const datePicker = document.createElement('div');
-    datePicker.className = 'date-picker-container';
-    datePicker.innerHTML = `
-    <div class="date-picker-overlay"></div>
-    <div class="date-picker-modal">
-      <div class="date-picker-header">
-        <h3>选择导出起始日期</h3>
-        <button class="date-picker-close" aria-label="关闭">
-          <svg width="15" height="15" viewBox="0 0 15 15" fill="none">
-            <path d="M1.5 1.5l12 12m-12 0l12-12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
-          </svg>
-        </button>
-      </div>
-      <div class="date-picker-body">
-        <div class="date-picker-inputs">
-          <div class="date-input-group">
-            <input type="number" id="year" min="2010" max="${new Date().getFullYear()}" value="${new Date().getFullYear()}">
-            <label for="year">年</label>
-          </div>
-          <div class="date-input-group">
-            <input type="number" id="month" min="1" max="12" value="${new Date().getMonth() + 1}">
-            <label for="month">月</label>
-          </div>
-          <div class="date-input-group">
-            <input type="number" id="day" min="1" max="31" value="${new Date().getDate()}">
-            <label for="day">日</label>
-          </div>
-        </div>
-      </div>
-      <div class="date-picker-footer">
-        <button class="date-picker-btn secondary" id="skip-btn">跳过选择</button>
-        <div class="button-group">
-          <button class="date-picker-btn" id="cancel-btn">取消</button>
-          <button class="date-picker-btn primary" id="confirm-btn">确认</button>
-        </div>
-      </div>
-    </div>
-  `;
-
-    // 添加样式
-    const style = document.createElement('style');
-    style.textContent = `
-    .date-picker-container {
-      position: fixed;
-      top: 0;
-      left: 0;
-      width: 100%;
-      height: 100%;
-      z-index: 10000;
-      display: flex;
-      align-items: center;
-      justify-content: center;
-      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
-    }
-
-    .date-picker-overlay {
-      position: fixed;
-      top: 0;
-      left: 0;
-      width: 100%;
-      height: 100%;
-      background: rgba(0, 0, 0, 0.4);
-      backdrop-filter: blur(4px);
-      -webkit-backdrop-filter: blur(4px);
-    }
-
-    .date-picker-modal {
-      position: relative;
-      background: white;
-      border-radius: 16px;
-      width: 90%;
-      max-width: 400px;
-      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
-      z-index: 10001;
-      animation: modalAppear 0.2s ease-out;
-    }
-
-    @keyframes modalAppear {
-      from {
-        opacity: 0;
-        transform: scale(0.95);
-      }
-      to {
-        opacity: 1;
-        transform: scale(1);
-      }
-    }
-
-    .date-picker-header {
-      display: flex;
-      justify-content: space-between;
-      align-items: center;
-      padding: 20px 24px;
-    }
-
-    .date-picker-header h3 {
-      margin: 0;
-      font-size: 18px;
-      font-weight: 600;
-      color: #000;
-    }
-
-    .date-picker-close {
-      padding: 8px;
-      border: none;
-      background: none;
-      cursor: pointer;
-      color: #666;
-      border-radius: 8px;
-      display: flex;
-      align-items: center;
-      justify-content: center;
-      transition: all 0.2s;
-    }
-
-    .date-picker-close:hover {
-      background: #f5f5f5;
-      color: #000;
-    }
-
-    .date-picker-body {
-      padding: 0 24px 24px;
-    }
-
-    .date-picker-inputs {
-      display: flex;
-      gap: 12px;
-    }
-
-    .date-input-group {
-      flex: 1;
-      display: flex;
-      flex-direction: column;
-    }
-
-    .date-input-group input {
-      width: 100%;
-      padding: 12px;
-      border: 1px solid #e5e7eb;
-      border-radius: 8px;
-      font-size: 16px;
-      outline: none;
-      transition: all 0.2s;
-      -moz-appearance: textfield;
-    }
-
-    .date-input-group input::-webkit-outer-spin-button,
-    .date-input-group input::-webkit-inner-spin-button {
-      -webkit-appearance: none;
-      margin: 0;
-    }
-
-    .date-input-group input:focus {
-      border-color: #1e90ff;
-      box-shadow: 0 0 0 3px rgba(30, 144, 255, 0.1);
-    }
-
-    .date-input-group label {
-      margin-top: 6px;
-      font-size: 13px;
-      color: #666;
-      text-align: center;
-    }
-
-    .date-picker-footer {
-      padding: 16px 24px;
-      border-top: 1px solid #f0f0f0;
-      display: flex;
-      justify-content: space-between;
-      align-items: center;
-    }
-
-    .button-group {
-      display: flex;
-      gap: 8px;
-    }
-
-    .date-picker-btn {
-      padding: 8px 16px;
-      border: none;
-      border-radius: 8px;
-      font-size: 14px;
-      font-weight: 500;
-      cursor: pointer;
-      transition: all 0.2s;
-      background: #fff;
-      color: #666;
-    }
-
-    .date-picker-btn:hover {
-      background: #f5f5f5;
-    }
-
-    .date-picker-btn.primary {
-      background: #1e90ff;
-      color: white;
-    }
-
-    .date-picker-btn.primary:hover {
-      background: #1a7ee6;
-    }
-
-    .date-picker-btn.secondary {
-      color: #666;
-    }
-
-    .date-picker-btn.secondary:hover {
-      background: #f5f5f5;
-      color: #000;
-    }
-  `;
-    document.head.appendChild(style);
-    document.body.appendChild(datePicker);
-
-    return new Promise((resolve) => {
-      // 取消按钮
-      document.getElementById('cancel-btn').addEventListener('click', () => {
-        document.body.removeChild(datePicker);
-        resolve(null);
-      });
-
-      // 关闭按钮
-      document.querySelector('.date-picker-close').addEventListener('click', () => {
-        document.body.removeChild(datePicker);
-        resolve(null);
-      });
-
-      // 跳过按钮
-      document.getElementById('skip-btn').addEventListener('click', () => {
-        document.body.removeChild(datePicker);
-        resolve(false);
-      });
-
-      // 确认按钮
-      document.getElementById('confirm-btn').addEventListener('click', () => {
-        const year = parseInt(document.getElementById('year').value, 10);
-        const month = parseInt(document.getElementById('month').value, 10);
-        const day = parseInt(document.getElementById('day').value, 10);
-
-        // 简单验证
-        const currentDate = new Date();
-        if (year > currentDate.getFullYear() || 
-            (year === currentDate.getFullYear() && month > currentDate.getMonth() + 1) ||
-            (year === currentDate.getFullYear() && month === currentDate.getMonth() + 1 && day > currentDate.getDate())) {
-          alert('所选日期不能超过当前日期');
-          return;
-        }
-
-        // 验证日期是否有效
-        const date = new Date(year, month - 1, day);
-        if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
-          alert('所选日期无效，请检查日期是否存在');
-          return;
-        }
-
-        document.body.removeChild(datePicker);
-        resolve({ year, month, day });
-      });
-    });
-  }
-
   // 版本信息
   const VERSION = '2.0.0';
 
@@ -1225,8 +764,8 @@
         }
 
         // 初始化日志
-        console.log(`%c QQ Chat Exporter Pro v${VERSION} %c | https://github.com/shuakami/qq-chat-exporter `, 
-          'background:#1e90ff;color:#fff;padding:5px 10px;border-radius:4px 0 0 4px;', 
+        console.log(`%c QQ Chat Exporter Pro v${VERSION} %c | https://github.com/shuakami/qq-chat-exporter `,
+          'background:#1e90ff;color:#fff;padding:5px 10px;border-radius:4px 0 0 4px;',
           'background:#fff;color:#1e90ff;padding:5px 10px;border-radius:0 4px 4px 0;border:1px solid #1e90ff;');
 
         // 确保Selection API可用
@@ -1238,37 +777,6 @@
         // 初始化基础配置
         logger.startSection('初始化配置');
 
-        // 0.0 日期选择 - 在开始导出前询问用户是否要选择特定日期
-        logger.info("加载日期选择器...");
-        const targetDate = await createDatePicker();
-        
-        // 如果用户选择了日期，则导航到该日期并处理消息
-        if (targetDate) {
-          logger.highlight(`用户选择了日期: ${targetDate.year}-${targetDate.month}-${targetDate.day}`);
-          
-          const dateSelected = await selectSpecificDate(targetDate);
-          if (!dateSelected) {
-            logger.error("日期选择失败，可能是该日期没有聊天记录。即将使用当前日期继续。");
-            await delay$1(2000); // 给用户时间阅读错误信息
-          } else {
-            logger.success("日期选择成功！");
-            
-            // 处理该日期的最新消息
-            const messageProcessed = await processLatestChatMessage();
-            if (!messageProcessed) {
-              logger.warning("处理消息失败，可能无法跳转到选定的聊天记录位置。即将继续导出当前可见消息。");
-              await delay$1(2000); // 给用户时间阅读警告信息
-            } else {
-              logger.success("已成功导航到选定的聊天记录位置！");
-              await delay$1(1000); // 给页面一点时间加载
-            }
-          }
-        } else if (targetDate === false) {
-          logger.system("用户选择跳过日期选择，将从当前日期开始导出。");
-        } else {
-          logger.warning("用户取消了操作，但我们仍将继续导出当前可见的聊天记录。");
-        }
-
         // 0.0.1 滚动方向选择
         logger.info("选择滚动方向...");
         const scrollDirection = await new Promise(resolve => {
@@ -1312,7 +820,7 @@
           margin-bottom: 16px;
         `;
 
-          const createButton = (text, value, description) => {
+          const createButton = (text, value, desc) => {
             const button = document.createElement('button');
             button.style.cssText = `
             flex: 1;
@@ -1329,14 +837,14 @@
             color: #666;
             min-height: 120px;
           `;
-            
+
             const iconSpan = document.createElement('span');
             iconSpan.textContent = value === 'up' ? '⬆️' : '⬇️';
             iconSpan.style.cssText = `
             font-size: 28px;
             margin-bottom: 4px;
           `;
-            
+
             const textSpan = document.createElement('span');
             textSpan.textContent = text;
             textSpan.style.cssText = `
@@ -1344,16 +852,16 @@
             font-weight: 500;
             margin-bottom: 8px;
           `;
-            
+
             const descSpan = document.createElement('span');
-            descSpan.textContent = description;
+            descSpan.textContent = desc;
             descSpan.style.cssText = `
             font-size: 13px;
             color: #888;
             text-align: center;
             line-height: 1.4;
           `;
-            
+
             button.appendChild(iconSpan);
             button.appendChild(textSpan);
             button.appendChild(descSpan);
@@ -1445,31 +953,32 @@
         }
 
         // 全局数据
-        window.collectedMessages = [];    // 保存所有提取到的消息
+        // 优化：不在内存中长期存放所有消息，仅临时存储一批后写入
+        window.collectedMessages = [];
         window.processedIds = new Set();  // 用于去重
 
         // ========== 0.1 主要滚动参数 ==========
-        const upTimes = scrollDirection === 'up' ? 5 : 1;     // 上滑次数
-        const downTimes = scrollDirection === 'up' ? 1 : 10;    // 下滑次数
-        
+        const upTimes = (scrollDirection === 'up') ? 5 : 2;    // 上滑次数
+        const downTimes = (scrollDirection === 'up') ? 2 : 10; // 下滑次数
+
         // 根据滚动方向设置不同的延迟时间
         const getDelayTime = (direction) => {
           if (direction === 'down') {
             return {
               scrollDelay: 300,      // 向下滚动等待时间
               focusInterval: 100,    // 向下滚动时焦点间隔
-              scrollDuration: 1800    // 向下滚动时持续时间
+              scrollDuration: 1800   // 向下滚动时持续时间
             };
           } else {
             return {
-              scrollDelay: 900,      // 向上滚动等待时间
-              focusInterval: 300,    // 向上滚动时焦点间隔
-              scrollDuration: 2400   // 向上滚动时持续时间
+              scrollDelay: 450,      // 向上滚动等待时间
+              focusInterval: 150,    // 向上滚动时焦点间隔
+              scrollDuration: 1200   // 向上滚动时持续时间
             };
           }
         };
 
-        const maxNoNewTimes = 20;         // 连续n次无新消息则停止
+        const maxNoNewTimes = 50;         // 连续n次无新消息则停止
         const scrollThreshold = 50;       // 滚动检测阈值
 
         // ========== 0.2 其他控制变量 ==========
@@ -1484,7 +993,13 @@
           isManualStop = true;
           logger.highlight('已手动停止自动滚动');
         };
-        
+
+        // 添加提前结束函数
+        window.finishNow = function() {
+          noNewTimes = maxNoNewTimes;
+          logger.highlight('已触发提前结束，正在完成最后的数据保存...');
+        };
+
         // 暴露导出和预览功能到全局作用域
         window.exportChatRecords = async (format, sortOrder) => {
           try {
@@ -1501,7 +1016,7 @@
             throw error;
           }
         };
-          
+
         window.previewChatRecords = async (sortOrder) => {
           try {
             if (!db) {
@@ -1517,19 +1032,12 @@
             throw error;
           }
         };
-        
+
         // 同时保持QCEPro对象的方法
         window.QCEPro.exportChatRecords = window.exportChatRecords;
         window.QCEPro.previewChatRecords = window.previewChatRecords;
-          
+
         window.howToExport = showExportHelp;
-        
-        // 暴露日期选择工具类
-        window.datePickerUtils = {
-          selectSpecificDate,
-          processLatestChatMessage,
-          delay: delay$1
-        };
 
         // 注册全局快捷键：Ctrl+F8 切换暂停/恢复
         window.addEventListener("keydown", function(e) {
@@ -1538,6 +1046,7 @@
             isPaused = !isPaused;
             if (isPaused) {
               logger.warning(`已暂停自动滚动 (Ctrl+F8 可恢复)`);
+              logger.warning('如果想提前结束采集，按Ctrl+F8继续，然后在控制台输入：window.finishNow() 并回车');
             } else {
               logger.success(`已恢复自动滚动`);
             }
@@ -1552,11 +1061,14 @@
 
         // ========== 1. 主循环: 5次上滑 + 1次下滑的反复 ==========
         logger.startSection('开始滚动采集');
+        let consecutiveInvalidScrolls = 0;  // 添加连续无效滚动计数器
+        let hasTriedRecovery = false;      // 添加恢复机制执行标记
+        
         mainLoop: while (!isManualStop) {
           // 检查是否处于暂停状态
           while (isPaused && !isManualStop) {
             logger.system("运行已暂停...等待恢复 (Ctrl+F8)");
-            await delay$1(1000);
+            await delay(1000);
           }
 
           // 1.1 先执行 upTimes 次"上滑"
@@ -1574,11 +1086,18 @@
         }
 
         logger.endSection('滚动采集');
-        logger.success(`共收集消息数: ${window.collectedMessages.length}条`);
+        logger.success(`【本次采集结束】已收集消息数: ${window.processedIds.size} 条`);
         
+        // 如果是异常终止（连续无新消息或手动停止），提示继续任务
+        if (noNewTimes >= maxNoNewTimes || isManualStop) {
+          logger.system('如果说采集意外中断了？');
+          logger.system('别担心！如果想继续采集剩余的消息：');
+          logger.system('在控制台输入：window.QCEPro.continueTask() 并回车');
+        }
+
         // 创建导出工具UI
         try {
-          const chatExporter = await createChatExporter(db, recordId, window.collectedMessages.length);
+          const chatExporter = await createChatExporter(db, recordId, window.processedIds.size);
           if (!chatExporter) {
             throw new Error("导出工具UI创建失败");
           }
@@ -1586,97 +1105,111 @@
           logger.error(`创建导出工具失败: ${error.message}`);
           throw error;
         }
-        
+
         // 显示导出帮助信息
         showExportHelp();
-        
+
         // 显示可爱的点赞请求
         showStarRequest();
-        
+
         logger.highlight('如果你要重新执行脚本/切换好友继续进行备份，请一定要先点击F5刷新后继续。');
 
-        // ========== 2. 定义"单步滚动+提取"函数 ==========
-        // 返回 true 表示应终止整个上滑逻辑
+        // ========== 2. 优化后的 "单步滚动+提取"函数 ==========
+        // 返回 true 表示应终止整个滚动逻辑
         async function doScrollOneStep(direction) {
           cycleCount++;
-          const oldScrollTop = container.scrollTop;
-          
-          // 获取当前方向的延迟时间
-          const delayTimes = getDelayTime(direction);
-          
           logger.event(`[滚动] 第${cycleCount}次, 方向=${direction}, 方法=${activeMethod}`);
-          
-          // 2.1 确保容器获得焦点
+
+          // 2.1 聚焦容器，并等待片刻以确保DOM渲染稳定
+          const { focusInterval, scrollDuration, scrollDelay } = getDelayTime(direction);
           container.focus();
-          await delay$1(delayTimes.focusInterval);
-          
-          // 2.2 使用当前活动方法滚动
-          await scrollWithMethod(container, direction, activeMethod, delayTimes.scrollDuration);
-          
-          // 检查滚动是否生效
-          await delay$1(delayTimes.scrollDelay);
+          await delay(focusInterval);
+
+          // 2.2 初次滚动
+          const oldScrollTop = container.scrollTop;
+          await scrollWithMethod(container, direction, activeMethod, scrollDuration);
+          await delay(scrollDelay);
+
+          // 2.3 判断滚动有效性，若不足阈值则切换方法再滚一次
           const newScrollTop = container.scrollTop;
           const scrollDiff = Math.abs(newScrollTop - oldScrollTop);
           
           if (scrollDiff < scrollThreshold) {
-            // 切换到下一种方法
+            consecutiveInvalidScrolls++;
             activeMethod = (activeMethod + 1) % 5;
             logger.warning(`滚动无效 (差异: ${scrollDiff}px)，切换到方法 ${activeMethod}`);
-            await scrollWithMethod(container, direction, activeMethod, delayTimes.scrollDuration);
-            await delay$1(delayTimes.scrollDelay);
           } else {
             logger.system(`滚动成功，位移: ${scrollDiff}px，方向: ${direction}`);
+            consecutiveInvalidScrolls = 0;  // 重置连续无效计数器
           }
 
-          // 2.3 提取本次新增消息，并存入 IndexedDB
-          const newCount = extractNewMessagesAndLog();
+          // 2.4 提取本次新增消息
+          const newCount = await extractNewMessagesAndLog();
           if (newCount > 0) {
-            // 将新增消息添加至 IndexedDB（附加 session 和 timestamp 字段）
-            const newMsgs = window.collectedMessages.slice(-newCount);
-            newMsgs.forEach(msg => {
-              msg.session = recordId;
-              msg.timestamp = new Date().toISOString();
-            });
-            try {
-              await db.records.bulkAdd(newMsgs);
-              logger.success(`已存储 ${newCount} 条新增消息到数据库`);
-            } catch (error) {
-              logger.error(`存储消息到数据库失败: ${error.message}`);
-            }
             noNewTimes = 0;
+            consecutiveInvalidScrolls = 0;  // 有新消息时也重置连续无效计数器
+            hasTriedRecovery = false;       // 有新消息时重置恢复机制标记
           } else {
             noNewTimes++;
-            logger.system(`无新消息，已连续 ${noNewTimes}/${maxNoNewTimes} 次`);
+            logger.system(`无新消息，已连续 ${noNewTimes}/${maxNoNewTimes} 次 （出现此提示请不要担心，到达限制时系统会自动停止）`);
+            
+            // 在连续25次无新消息且未执行过恢复机制时，尝试恢复
+            if (noNewTimes >= 25 && !hasTriedRecovery) {
+              logger.warning('检测到连续25次无新消息，启动恢复机制...');
+              logger.system('暂停5秒，然后尝试反向滚动来恢复...');
+              
+              // 暂停5秒
+              await delay(5000);
+              
+              // 执行2次反向滚动
+              const oppositeDirection = direction === 'up' ? 'down' : 'up';
+              logger.system(`执行反向滚动 (${oppositeDirection})...`);
+              
+              for (let i = 0; i < 2; i++) {
+                await scrollWithMethod(container, oppositeDirection, activeMethod, scrollDuration * 1.5);
+                await delay(scrollDelay * 1.5);
+              }
+              
+              // 标记已执行过恢复机制
+              hasTriedRecovery = true;
+              logger.system('恢复机制执行完毕，继续正常滚动...');
+              logger.system('如果后续仍然无效，将等待达到最大无消息次数后自动停止。');
+            }
+            
             if (noNewTimes >= maxNoNewTimes) {
               logger.warning(`已达到最大无消息次数 (${maxNoNewTimes})，停止滚动`);
-              return true;
+              return true; // 结束整个滚动流程
             }
           }
-
-          return false;
+          return false; // 继续
         }
 
-        // ========== 3. 提取当前DOM中出现的"新消息"并打印 ==========
-        function extractNewMessagesAndLog() {
+        // ========== 3. 从DOM中提取新的消息并写入DB ==========
+        async function extractNewMessagesAndLog() {
           let newCount = 0;
           const items = document.querySelectorAll(messageItemSelector);
-          for (const item of items) {
+          const batchToSave = [];
+
+          for (let i = 0; i < items.length; i++) {
+            const item = items[i];
             const id = item.getAttribute('id') || '';
             if (!id || window.processedIds.has(id)) {
               continue;
             }
+
             const timeEl = item.querySelector('.message__timestamp .babble');
             const time = timeEl ? timeEl.innerText.trim() : '';
+
             const avatarSpan = item.querySelector('.avatar-span');
-            const sender = avatarSpan ? avatarSpan.getAttribute('aria-label') || '' : '';
+            const sender = avatarSpan ? (avatarSpan.getAttribute('aria-label') || '') : '';
+
             let content = '';
-            
-            // 文本消息处理
+            // 文本消息
             const textEl = item.querySelector('.text-element');
             if (textEl && textEl.innerText.trim() !== '') {
               content = textEl.innerText.trim();
-            } 
-            // 图片消息处理
+            }
+            // 图片或视频
             else {
               const imgEl = item.querySelector('img.image-content');
               if (imgEl) {
@@ -1685,60 +1218,73 @@
                 if (src.startsWith('data:')) {
                   src = src.slice(0, 50) + '...';
                 }
-                
-                // 判断是否为视频消息
+
+                // 检查视频
                 const videoElement = item.querySelector('.msg-preview--video');
                 if (videoElement) {
-                  // 视频消息处理
-                  // 尝试获取视频文件路径
                   const finalSrc = videoElement.getAttribute('finalsrc') || '';
                   const videoLabel = videoElement.getAttribute('aria-label') || '视频';
-                  
                   if (finalSrc) {
                     content = `[${videoLabel}] 路径: ${finalSrc}`;
                   } else {
                     content = `[${videoLabel}] 预览: ${dataPath || src}`;
                   }
                 } else {
-                  // 普通图片消息
                   content = `[图片] ${dataPath ? '路径: ' + dataPath : '预览: ' + src}`;
                 }
               }
-              
-              // 如果没有找到图片元素，单独检查是否为视频消息
+
+              // 如果没有找到图片元素，单独检查是否为视频
               if (!content) {
                 const videoElement = item.querySelector('.msg-preview--video');
                 if (videoElement) {
                   const finalSrc = videoElement.getAttribute('finalsrc') || '';
                   const imgInVideo = videoElement.querySelector('img.image-content');
                   let videoPath = '';
-                  
                   if (imgInVideo) {
-                    videoPath = imgInVideo.getAttribute('data-path') || imgInVideo.getAttribute('src') || '';
+                    videoPath = imgInVideo.getAttribute('data-path') ||
+                                imgInVideo.getAttribute('src') || '';
                   }
-                  
-                  content = `[视频] ${finalSrc ? '路径: ' + finalSrc : (videoPath ? '预览: ' + videoPath : '未知视频文件')}`;
+                  content = `[视频] ${
+                  finalSrc ? '路径: ' + finalSrc :
+                  (videoPath ? '预览: ' + videoPath : '未知视频文件')
+                }`;
                 }
               }
             }
-            
-            // 如果还是没有内容，尝试查找其他可能的消息类型
+
+            // 如果还是没有内容，尝试其他类型
             if (!content) {
-              if (item.textContent.trim()) {
-                content = `[未识别消息] ${item.textContent.trim().substring(0, 100)}${item.textContent.trim().length > 100 ? '...' : ''}`;
+              const pureText = (item.textContent || '').trim();
+              if (pureText) {
+                content = `[未识别消息] ${pureText.substring(0, 100)}${pureText.length > 100 ? '...' : ''}`;
               } else {
                 content = '[未识别消息类型]';
               }
             }
-            
-            const messageData = { id, time, sender, content };
-            window.collectedMessages.push(messageData);
+
+            const messageData = {
+              id,
+              time,
+              sender,
+              content,
+              session: recordId,
+              timestamp: new Date().toISOString()
+            };
+
+            batchToSave.push(messageData);
             window.processedIds.add(id);
             newCount++;
-            
-            // 简洁日志
-            if (newCount % 5 === 0 || newCount === 1) {
-              logger.count(`已获取 ${window.collectedMessages.length} 条消息`);
+          }
+
+          // 将新消息批量写入IndexedDB
+          if (batchToSave.length > 0) {
+            try {
+              await db.records.bulkAdd(batchToSave);
+              window.collectedMessages = batchToSave; // 仅保留本次新增批次，减少内存占用
+              logger.success(`新增消息 ${newCount} 条 (累计总量: ${window.processedIds.size})`);
+            } catch (error) {
+              logger.error(`存储消息到数据库失败: ${error.message}`);
             }
           }
           return newCount;
@@ -1747,6 +1293,109 @@
         console.error('初始化失败:', error);
       }
     },
+    
+    // 添加继续任务方法
+    continueTask: async function() {
+      try {
+        logger.startSection('继续未完成任务');
+        
+        // 1. 确保 Dexie.js 已加载
+        if (!window.Dexie) {
+          logger.info("正在从国内CDN加载 Dexie.js...");
+          await new Promise((resolve, reject) => {
+            const script = document.createElement("script");
+            script.src = "https://cdn.bootcdn.net/ajax/libs/dexie/3.2.2/dexie.min.js";
+            script.onload = resolve;
+            script.onerror = (error) => {
+              logger.error("Dexie.js 加载失败，尝试使用备用CDN...");
+              script.src = "https://cdn.jsdelivr.net/npm/dexie@3.2.2/dist/dexie.min.js";
+              script.onload = resolve;
+              script.onerror = reject;
+            };
+            document.head.appendChild(script);
+          }).catch(error => {
+            logger.error("所有CDN加载失败，请检查网络连接");
+            throw new Error("依赖加载失败: " + error);
+          });
+          logger.success("Dexie.js 已成功加载");
+        }
+
+        // 2. 获取所有数据库列表
+        const dbList = await Dexie.getDatabaseNames();
+        const chatDbs = dbList.filter(name => name.startsWith('ChatRecords_'))
+          .sort((a, b) => {
+            const timeA = parseInt(a.split('_')[1].split('-')[0]);
+            const timeB = parseInt(b.split('_')[1].split('-')[0]);
+            return timeB - timeA;  // 降序排列
+          });
+        
+        if (chatDbs.length === 0) {
+          logger.error('未找到任何历史记录数据库');
+          return;
+        }
+
+        // 3. 显示所有数据库的详细信息
+        logger.highlight('找到以下历史记录数据库：');
+        for (const dbName of chatDbs) {
+          const db = new Dexie(dbName);
+          db.version(1).stores({
+            records: '++id, session, timestamp, time, sender, content'
+          });
+
+          // 获取该数据库的所有记录
+          const records = await db.records.toArray();
+          if (records.length === 0) continue;
+
+          // 获取对话者信息
+          const senders = [...new Set(records.map(r => r.sender))].filter(Boolean);
+          const participants = senders.join(' 与 ') || '未知对话者';
+
+          // 获取时间范围
+          const times = records.map(r => r.time).filter(Boolean);
+          const firstTime = times[0];
+          const lastTime = times[times.length - 1];
+
+          // 获取消息类型统计
+          const textMsgs = records.filter(r => !r.content.startsWith('[') && !r.content.includes('未识别')).length;
+          const imgMsgs = records.filter(r => r.content.includes('[图片]')).length;
+          const videoMsgs = records.filter(r => r.content.includes('[视频]')).length;
+          const otherMsgs = records.length - textMsgs - imgMsgs - videoMsgs;
+
+          // 显示数据库详细信息
+          logger.system(`\n== 数据库：${dbName} ==`);
+          logger.system(`对话者：${participants}`);
+          logger.system(`总消息数：${records.length} 条`);
+          logger.system(`时间范围：${firstTime} 至 ${lastTime}`);
+          logger.system('消息类型统计：');
+          logger.system(`- 文本消息：${textMsgs} 条`);
+          logger.system(`- 图片消息：${imgMsgs} 条`);
+          logger.system(`- 视频消息：${videoMsgs} 条`);
+          logger.system(`- 其他类型：${otherMsgs} 条`);
+        }
+
+        // 4. 获取最新数据库的最后记录
+        const latestDb = new Dexie(chatDbs[0]);
+        latestDb.version(1).stores({
+          records: '++id, session, timestamp, time, sender, content'
+        });
+        const lastRecord = await latestDb.records.orderBy('id').last();
+        
+        // 5. 显示继续采集的操作指引
+        logger.highlight('\n=== 如何继续采集 ===');
+        logger.system('1. 请先刷新页面（按F5）');
+        logger.system('2. 重新运行脚本');
+        logger.system('3. 点击QQ聊天窗口右上角的"消息记录"按钮');
+        logger.system(`4. 找到这个时间点附近的消息：${lastRecord.time}`);
+        logger.system('5. 点击该消息，页面会自动滚动到对应位置');
+        logger.system('6. 重新运行脚本，开始采集');
+        logger.system('\n提示：每次继续采集前，都需要先刷新页面(F5)，这样可以确保数据采集的准确性。');
+        
+      } catch (error) {
+        logger.error(`继续任务失败: ${error.message}`);
+        console.error('继续任务失败:', error);
+      }
+    },
+    
     showExportHelp,
     exportChatRecords,
     previewChatRecords
diff --git a/public/index.html b/public/index.html
index 9b0b820..0a090ef 100644
--- a/public/index.html
+++ b/public/index.html
@@ -480,6 +480,20 @@
         
         <p class="note-warning">导出完一个人的数据后，如果要导另一个人，<span class="highlight">必须</span>先在控制台按F5刷新，再执行脚本。
             <br/>不要不刷新就重复执行脚本，会出问题。</p>
+
+        <div class="notes-section">
+            <p><strong>如果采集意外中断了怎么办？</strong></p>
+            <p>不用担心！如果采集过程意外中断，你可以这样继续：</p>
+            <ol>
+                <li>在控制台输入：<code>window.QCEPro.continueTask()</code></li>
+                <li>刷新页面（按F5）</li>
+                <li>在弹出的历史记录中找到对应的时间点</li>
+                <li>点击消息记录按钮，找到那个时间点的消息</li>
+                <li>重新运行上面的导入代码</li>
+                <li>重新运行脚本就可以继续采集了</li>
+            </ol>
+            <p>提示：每次继续采集前，都需要先刷新页面(F5)，这样可以确保数据采集的准确性。</p>
+        </div>
         
         <p>如果你的聊天数据在手机上，可以先在QQ设置里把手机聊天记录导到电脑上，再按上面步骤操作。</p>
         
diff --git a/utils/datePicker.js b/utils/datePicker.js
index 8e289df..2e6ad46 100644
--- a/utils/datePicker.js
+++ b/utils/datePicker.js
@@ -49,8 +49,18 @@ export async function selectSpecificDate(targetDate) {
     return false; // 返回 false 表示选择失败
   }
 
-  // 步骤 0: 点击筛选按钮
-  const filterButtonCssPath = 'div.record-filter-btn[data-v-35f48dfb]';
+  // 步骤 0: 点击聊天记录按钮
+  const messageRecordButton = document.querySelector('#id-func-bar-MessageRecord');
+  if (messageRecordButton) {
+    simulateClick(messageRecordButton);
+    await delay(1000); // 等待聊天记录面板展开
+  } else {
+    console.error('无法找到聊天记录按钮。');
+    return false;
+  }
+
+  // 步骤 1: 点击筛选按钮
+  const filterButtonCssPath = 'div.record-filter-btn';
   const filterButton = document.querySelector(filterButtonCssPath);
   if (filterButton) {
     simulateClick(filterButton);
@@ -60,12 +70,12 @@ export async function selectSpecificDate(targetDate) {
     return false; // 返回 false 表示选择失败
   }
 
-  // 步骤 1: 点击打开日期选择器
+  // 步骤 2: 点击打开日期选择器
   const openDatePickerCssPath = 'div#ml-root > div:nth-of-type(3) > div > div:nth-of-type(2) > div:nth-of-type(2) > div';
   simulateClick(document.querySelector(openDatePickerCssPath));
   await delay(500); // 等待日期选择器展开
 
-  // 步骤 2: 导航到目标月份
+  // 步骤 3: 导航到目标月份
   let resetAttempted = false;
 
   while (true) {
@@ -117,7 +127,7 @@ export async function selectSpecificDate(targetDate) {
     }
   }
 
-  // 步骤 3: 选择目标日期并判断是否禁用
+  // 步骤 4: 选择目标日期并判断是否禁用
   const dayElements = document.querySelectorAll('div.vc-weeks div.vc-day');
   let targetDayFound = false;
 
@@ -225,7 +235,10 @@ export function createDatePicker(onSelect) {
         </div>
       </div>
       <div class="date-picker-footer">
-        <button class="date-picker-btn secondary" id="skip-btn">跳过选择</button>
+        <div class="date-picker-actions">
+          <button class="date-picker-btn secondary" id="continue-task-btn">继续未完成的任务</button>
+          <button class="date-picker-btn secondary" id="skip-btn">跳过选择</button>
+        </div>
         <div class="button-group">
           <button class="date-picker-btn" id="cancel-btn">取消</button>
           <button class="date-picker-btn primary" id="confirm-btn">确认</button>
@@ -266,7 +279,7 @@ export function createDatePicker(onSelect) {
       background: white;
       border-radius: 16px;
       width: 90%;
-      max-width: 400px;
+      max-width: 500px;
       box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
       z-index: 10001;
       animation: modalAppear 0.2s ease-out;
@@ -405,11 +418,71 @@ export function createDatePicker(onSelect) {
       background: #f5f5f5;
       color: #000;
     }
+
+    .date-picker-actions {
+      display: flex;
+      gap: 8px;
+    }
+    
+    .date-picker-btn.continue-task {
+      background: #f0f9ff;
+      color: #1e90ff;
+      border: 1px solid #1e90ff;
+    }
+    
+    .date-picker-btn.continue-task:hover {
+      background: #e6f4ff;
+    }
   `;
   document.head.appendChild(style);
   document.body.appendChild(datePicker);
 
   return new Promise((resolve) => {
+    // 继续任务按钮
+    document.getElementById('continue-task-btn').addEventListener('click', async () => {
+      try {
+        // 检查 Dexie.js 是否已加载
+        if (!window.Dexie) {
+          // 尝试加载 Dexie.js
+          try {
+            await new Promise((resolve, reject) => {
+              const script = document.createElement("script");
+              script.src = "https://cdn.bootcdn.net/ajax/libs/dexie/3.2.2/dexie.min.js";
+              script.onload = resolve;
+              script.onerror = (error) => {
+                script.src = "https://cdn.jsdelivr.net/npm/dexie@3.2.2/dist/dexie.min.js";
+                script.onload = resolve;
+                script.onerror = reject;
+              };
+              document.head.appendChild(script);
+            });
+          } catch (error) {
+            alert('无法加载必要的依赖 Dexie.js，请检查网络连接后刷新页面重试');
+            return;
+          }
+        }
+
+        // 使用QCEPro的continueTask方法
+        if (window.QCEPro && window.QCEPro.continueTask) {
+          const targetDate = await window.QCEPro.continueTask();
+          if (targetDate) {
+            // 先移除日期选择器
+            if (document.body.contains(datePicker)) {
+              document.body.removeChild(datePicker);
+            }
+            resolve(targetDate);
+          } else {
+            alert('无法继续任务，请手动选择日期或刷新页面重试');
+          }
+        } else {
+          alert('继续任务功能未就绪，请刷新页面重试');
+        }
+      } catch (error) {
+        console.error('继续任务失败:', error);
+        alert('继续任务失败: ' + error.message);
+      }
+    });
+
     // 取消按钮
     document.getElementById('cancel-btn').addEventListener('click', () => {
       document.body.removeChild(datePicker);
